## 一、实验目的

本实验目的是加强学生对位级运算的理解及熟练使用的能力。

## 二、报告要求

本报告要求学生把实验中实现的所有函数逐一进行分析说明，写出实现的依据，也就是推理过程，可以是一个简单的数学证明，也可以是代码分析，根据实现中你的想法不同而异。

## 三、函数分析

### 1.bitXor函数

**函数要求：**

函数名 | bitXor
-|-
参数 | int , int
功能实现 | x^y
要求 | 只能使用 ~ 和 \|运算符，将结果返回

**实现分析：**

要实现按位异或操作，可以利用按位与、按位取反和按位或运算符。具体地，可以利用以下等价关系来实现：

a \^ b = (a \& \~ b) | (\~a \& b) 

这里 \(\^\) 表示按位异或，\(\&\) 表示按位与，\(\~\) 表示按位取反，\(|\) 表示按位或。这个等价关系可以利用德摩根定律推导得出。

**函数实现：**

```C
int bitXor(int x, int y) {
    return ~(~(x & ~y) & ~(~x & y));
}
```

### 2.copyLSB函数

**函数要求：**

函数名 | copyLSB
-|-
参数 | int
功能实现 | 将输入整数的最低位复制到所有位
要求 | 使用位运算符，将结果返回。

**实现分析：**

表达式(x&1) 用于提取整数x的最低有效位（LSB），因为1的二进制表示为000...0001，与x进行按位与操作可以只保留x的最低位。然后，对提取的LSB取反，即∼(x&1)。这将LSB的值从0变为1，或者从1变为0。最后，加1操作+1将LSB的值转换为正常的表示形式，从而实现了复制LSB的功能。
**函数实现：**

```C
int copyLSB(int x) {
    return ~(x & 1) + 1;
}
```

### 3.isEqual函数

**函数要求：**

函数名 | isEqual
-|-
参数 | int , int
功能实现 | 判断两个整数是否相等
要求 | 只能使用 ^ 和 ! 运算符，将结果返回。

**实现分析：**
要判断两个整数是否相等，可以先通过异或操作获取两个整数不同的位，然后取反操作，如果结果为0，则表示两个整数相等。

**函数实现：**

```C
int isEqual(int x, int y) {
    return !(x ^ y);
}
```

### 4.bitMask函数

**函数要求：**

函数名 | bitMask
-|-
参数 | int
功能实现 | 生成一个掩码，将输入整数的最低位设置为1，其余位设置为0
要求 | 使用位运算符，将结果返回。

**实现分析：**
这个函数实现了生成一个位掩码的操作，用于将指定范围内的位设置为1。通过左移和按位与操作生成位掩码，将 lowbit 到 highbit 之间的位设置为1，其余位设置为0，并返回结果。

**函数实现：**

```C
int bitMask(int highbit, int lowbit) {
    return ((~0)<<lowbit)&((~0)+(2<<highbit));
}
```

### 5.tmax函数

**函数要求：**

函数名 | tmax
-|-
参数 | 无
功能实现 | 返回整数的最大值
要求 | 不使用常数，只使用位运算符，将结果返回。

**实现分析：**

1 << 31 表示将数字1左移31位，即在二进制表示中只有最高位为1，其余位都为0。

~(1 << 31) 对左移后的结果取反，即将最高位为1的数取反，最高位变为0，其余位变为1。

因此，函数返回的结果是一个除了最高位为0外，其余所有位都为1的整数。
**函数实现：**

```C
int tmax() {
    return ~(1 << 31);
}
```

### 6.isNonNegative函数

**函数要求：**

函数名 | isNonNegative
-|-
参数 | int
功能实现 | 判断整数是否为非负数
要求 | 使用位运算实现，返回1表示非负数，返回0表示负数。

**实现分析：**

该函数通过右移31位获取符号位，然后取反得到非负数的判断结果。

**函数实现：**

```C
int isNonNegative(int x) {
    return !(x >> 31 & 1);
}
```

### 7.addOK函数

**函数要求：**

函数名 | addOK
-|-
参数 | int , int
功能实现 | 判断整数相加是否溢出
要求 | 使用位运算实现，返回1表示未溢出，返回0表示溢出。

**实现分析：**

首先，计算x和y的和，存储在变量sum中：int sum = x + y;。

接着，计算(x ^ sum)和(y ^ sum)的按位与操作，然后将结果右移31位：((x ^ sum) & (y ^ sum)) >> 31。

(x ^ sum)表示x和sum的按位异或操作，结果为1的位表示x和sum对应位不同；
(y ^ sum)表示y和sum的按位异或操作，结果为1的位表示y和sum对应位不同；
(x ^ sum) & (y ^ sum)对上述结果进行按位与操作，得到的结果中，为1的位表示x和y在该位上同时与sum不同；
将上述结果右移31位，将结果的最高位移动到最低位，以便后续进行逻辑非操作。
最后，对上述结果取逻辑非操作：!(((x ^ sum) & (y ^ sum)) >> 31)。

如果x + y没有溢出，那么sum应该等于x + y，即x和y的每一位与sum应该相同，因此按位与的结果为0，取反后为1；
如果x + y发生了溢出，那么sum将不等于x + y，即x和y中至少有一位与sum不同，按位与的结果至少有一个为1，取反后为0。

**函数实现：**

```C
int addOK(int x, int y) {
    int sum = x + y;
    return !(((x ^ sum) & (y ^ sum)) >> 31 & 1);
}
```

### 8.isLess函数

**函数要求：**

函数名 | isLess
-|-
参数 |  int , int
功能实现 | 比较两个整数的大小
要求 | 使用位运算实现，返回1表示 x 小于 y，返回0表示 x 不小于 y。

**实现分析：**

首先，分别获取x和y的符号位：
int sign_x = (x >> 31) & 1; 获取x的符号位，即最高位；
int sign_y = (y >> 31) & 1; 获取y的符号位，即最高位。

计算符号位的差异和相同情况：
int sign_diff = sign_x ^ sign_y; 计算符号位是否相异，结果为1表示符号位不同；
int sign_same = ~(sign_x ^ sign_y); 计算符号位是否相同，结果为1表示符号位相同。

计算x - y的差值：
int diff = x + (~y + 1); 这里使用补码运算来计算差值，即x - y。

获取差值的符号位：
int sign_diff_mask = (diff >> 31) & 1; 获取差值的符号位。

最后，根据符号位的情况来判断x和y的大小关系：
(sign_diff & sign_x) 表示当符号位不同且x为负时，返回1；
(sign_same & sign_diff_mask) 表示当符号位相同且差值为负时，返回1。

**函数实现：**

```C
int isLess(int x, int y) {
    int sign_x = (x >> 31) & 1;
    int sign_y = (y >> 31) & 1;
    int sign_diff = sign_x ^ sign_y;
    int sign_same = ~(sign_x ^ sign_y);
    int diff = x + (~y + 1);
    int sign_diff_mask = (diff >> 31) & 1;

    return (sign_diff & sign_x) | (sign_same & sign_diff_mask);
}
```

### 9.float_neg函数

**函数要求：**

函数名 | float_neg
-|-
参数 | unsigned float
功能实现 | 对浮点数取反
要求 | 使用位运算实现，根据指数和尾数是否为特定值来判断是否为NaN，返回参数或者对符号位取反后的结果。

**实现分析：**

首先，提取浮点数uf的指数部分和尾数部分：
unsigned exp = uf & 0x7F800000; 提取uf的指数部分，即前8位；
unsigned frac = uf & 0x007FFFFF; 提取uf的尾数部分，即后23位。

检查特殊情况：
如果指数部分为0x7F800000且尾数部分不为0，表示uf为NaN（Not a Number），直接返回uf；
在IEEE 754标准中，如果指数部分为0x7F800000，表示为特殊值（如无穷大或NaN），此时只有尾数部分为0时才表示正负无穷大或正负0。

对正常情况下的浮点数进行取反操作：
return uf ^ 0x80000000; 将uf的最高位（符号位）取反，即将正数变为负数，负数变为正数。
**函数实现：**

```C
unsigned float_neg(unsigned uf) {
    unsigned exp = uf & 0x7F800000;
    unsigned frac = uf & 0x007FFFFF;

    if (exp == 0x7F800000 && frac != 0) {
        return uf;  // NaN
    }

    return uf ^ 0x80000000;
}
```

### 10.float_half函数

**函数要求：**

函数名 | float_half
-|-
参数 |  unsigned float
功能实现 | 对浮点数减半
要求 | 使用位运算实现，根据浮点数的表示格式，处理特殊情况和一般情况，最终返回减半后的浮点数。

**实现分析：**

首先，提取浮点数uf的指数部分、符号位和尾数部分：
int exp = (uf & 0x7F800000) >> 23; 提取uf的指数部分，即中间8位；
int s = uf & 0x80000000; 提取uf的符号位，即最高位；
int frac = uf & 0x7FFFFF; 提取uf的尾数部分，即后23位。

检查特殊情况：
如果指数部分为255（全1），表示特殊值（如无穷大或NaN），直接返回uf；
在IEEE 754标准中，如果指数部分大于1，则可以直接将指数部分减1，表示浮点数减半。

对正常情况下的浮点数进行减半操作：
如果指数部分大于1，将指数部分减1，然后重新组合符号位、指数部分和尾数部分；
如果尾数部分的最后两位为11，则需要对尾数部分进行调整，即加2，以避免舍入误差；
对于其他情况，将浮点数右移1位，然后重新组合符号位和尾数部分。
**函数实现：**

```C
unsigned float_half(unsigned uf) {
    int exp = (uf & 0x7F800000) >> 23;
    int s = uf & 0x80000000;
    int frac = uf & 0x7FFFFF;

    if(exp == 255) {
        return uf;
    } 
	else if(exp > 1) {
        exp = exp - 1;
        return s | (exp << 23) | frac;
    } 
	else if((uf & 0x3) == 0x3) {
        uf = uf + 0x2;
    }
    return ((uf >> 1) & 0x007FFFFF) | s;
}
```
